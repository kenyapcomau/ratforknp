$BATCH
C RATFOR - RATIONAL FORTRAN PREPROCESSOR
C BOOTSTRAP VERSION
C YAP SUE KEN 13/12/82
C
        CALL INIT
        CALL PARSE
        CALL FIN
        STOP
        END
        INTEGER FUNCTION ALLDIG(STR)
C ALLDIG - RETURN YES IF STR IS ALL DIGITS
        INTEGER TYPE
        INTEGER STR(100)
        INTEGER I
C
        ALLDIG=0
        IF(STR(1).EQ.0)RETURN
        I=1
100     IF(STR(I).EQ.0)GOTO 101
        IF(TYPE(STR(I)).NE.48)RETURN
        I=I+1
        GOTO 100
101     ALLDIG=1
        RETURN
        END
        SUBROUTINE BALPAR
C BALPAR - COPY BALANCED PARENTHESIZED STRING
        INTEGER GETTOK
        INTEGER T,TOKEN(80)
        INTEGER NLPAR
C
        IF(GETTOK(TOKEN,80).EQ.40)GOTO 100
        CALL SYNERR('MISSING LEFT PARENTHESIS.')
        RETURN
100     CALL OUTSTR(TOKEN)
        NLPAR=1
110     T=GETTOK(TOKEN,80)
        IF(.NOT.(T.EQ.59.OR.T.EQ.123.OR.T.EQ.125.OR.T.EQ.-1))GOTO 120
        CALL PBSTR(TOKEN)
        GOTO 111
120     IF(T.EQ.10)TOKEN(1)=0
        IF(T.EQ.40)NLPAR=NLPAR+1
        IF(T.EQ.41)NLPAR=NLPAR-1
        CALL OUTSTR(TOKEN)
        IF(NLPAR.GT.0)GOTO 110
111     IF(NLPAR.NE.0)
     $  CALL SYNERR('MISSING PARENTHESIS IN CONDITION.')
        RETURN
        END
        SUBROUTINE BRKNXT(SP,LEXTYP,LABVAL,TOKEN)
C BRKNXT - GENERATE CODE FOR BREAK AND NEXT
        INTEGER I,LABVAL(50),LEXTYP(50),SP,TOKEN
C
        I=SP
100     IF(I.LE.0)GOTO 101
        IF(.NOT.(LEXTYP(I).EQ.-15.OR.LEXTYP(I).EQ.-10.OR.LEXTYP(I).EQ.
     $  -16.OR.LEXTYP(I).EQ.-17))GOTO 110
        IF(TOKEN.NE.-8)GOTO 120
        CALL OUTGO(LABVAL(I)+1)
        GOTO 121
120     CALL OUTGO(LABVAL(I))
121     RETURN
110     I=I-1
        GOTO 100
101     IF(TOKEN.NE.-8)GOTO 130
        CALL SYNERR('ILLEGAL BREAK.')
        GOTO 131
130     CALL SYNERR('ILLEGAL NEXT.')
131     RETURN
        END
        INTEGER FUNCTION DEFTOK(TOKEN,TOKSIZ)
C DEFTOK - GET TOKEN; PROCESS MACRO CALLS
        INTEGER GTOK,LOOKUP
        INTEGER TOKSIZ,DEFN(80),T,TOKEN(80)
C
        T=GTOK(TOKEN,TOKSIZ)
100     IF(T.EQ.-1)GOTO 101
        IF(T.NE.65)GOTO 101
        IF(LOOKUP(TOKEN,DEFN).EQ.0)GOTO 101
        CALL PBSTR(DEFN)
        T=GTOK(TOKEN,TOKSIZ)
        GOTO 100
101     DEFTOK=T
        RETURN
        END
        SUBROUTINE DOCODE(LAB)
C DOCODE - GENERATE CODE FOR BEGINNING OF DO
        INTEGER LABGEN
        INTEGER LAB
        INTEGER DOSTR(4)
        DATA DOSTR/68,79,32,0/
C
        CALL OUTTAB
        CALL OUTSTR(DOSTR)
        LAB=LABGEN(2)
        CALL OUTNUM(LAB)
        CALL OUTCH(32)
        CALL EATUP
        CALL OUTDON
        RETURN
        END
        SUBROUTINE DOSTAT(LAB)
C DOSTAT - GENERATE CODE FOR END OF DO STATEMENT
        INTEGER LAB
C
        CALL OUTCON(LAB)
        CALL OUTCON(LAB+1)
        RETURN
        END
        SUBROUTINE EATUP
C EATUP - PROCESS REST OF STATEMENT; INTERPRET CONTINUATIONS
        INTEGER GETTOK
        INTEGER PTOKEN(80),T,TOKEN(80)
        INTEGER NLPAR
C
        NLPAR=0
100     T=GETTOK(TOKEN,80)
        IF(T.EQ.59.OR.T.EQ.10)GOTO 101
        IF(T.NE.125)GOTO 110
        CALL PBSTR(TOKEN)
        GOTO 101
110     CONTINUE
        IF(.NOT.(T.EQ.123.OR.T.EQ.-1))GOTO 120
        CALL SYNERR('UNXEPECTED BRACE OR EOF.')
        CALL PBSTR(TOKEN)
        GOTO 101
120     IF(T.NE.44)GOTO 130
        IF(GETTOK(PTOKEN,80).NE.10)CALL PBSTR(PTOKEN)
        GOTO 131
130     IF(T.EQ.40)NLPAR=NLPAR+1
        IF(T.EQ.41)NLPAR=NLPAR-1
131     CALL OUTSTR(TOKEN)
        IF(NLPAR.GE.0)GOTO 100
101     IF(NLPAR.NE.0)CALL SYNERR('UNBALANCED PARENTHESIS.')
        RETURN
        END
        SUBROUTINE ELSEIF(LAB)
C ELSEIF - GENERATE CODE FOR END OF IF BEFORE ELSE
        INTEGER LAB
C
        CALL OUTGO(LAB+1)
        CALL OUTCON(LAB)
        RETURN
        END
        INTEGER FUNCTION EQUAL(STR1,STR2)
C EQUAL - COMPARE STR1 TO STR2; RETURN YES OF EQUAL, NO IF NOT
        INTEGER STR1(100),STR2(100)
        INTEGER I
C
        I=1
100     IF(STR1(I).NE.STR2(I))GOTO 101
        IF(STR1(I).NE.0)GOTO 110
        EQUAL=1
        RETURN
110     I=I+1
        GOTO 100
101     EQUAL=0
        RETURN
        END
        SUBROUTINE ERROR(MSG)
C ERROR - PRINTS ERROR MESSAGE AND THEN HALTS
        CHARACTER*(*) MSG
C
        CALL REMARK(MSG)
        STOP 'FATAL ERROR DETECTED BY RATFOR'
        END
        SUBROUTINE FIN
C FIN - CLEAN UP BEFORE EXITING PROGRAM
        RETURN
        END
        SUBROUTINE FOLD(STR)
C FOLD - CONVERT ALL LOWER CASE TO UPPER
        INTEGER STR(100)
        INTEGER I
C
        I=1
100     IF(STR(I).EQ.0)RETURN
        IF(STR(I).GE.97.AND.STR(I).LE.122)
     $  STR(I)=STR(I)-32
        I=I+1
        GOTO 100
        END
        SUBROUTINE FORCOD(LAB)
C FORCOD - BEGINNING OF FOR STATEMENT
        INTEGER GETTOK
        INTEGER T,TOKEN(80)
        INTEGER LENGTH,LABGEN
        INTEGER I,J,LAB,NLPAR
        INTEGER IFNOT(9)
C
        INTEGER FORDEP
        INTEGER FORSTK
        COMMON /CFOR/FORDEP,FORSTK(100)
C
        DATA IFNOT/73,70,40,46,78,79,84,46,0/
C
        LAB=LABGEN(3)
        CALL OUTCON(0)
        IF(GETTOK(TOKEN,80).EQ.40)GOTO 100
        CALL SYNERR('MISSING LEFT PARENTHESIS.')
        RETURN
100     IF(GETTOK(TOKEN,80).EQ.59)GOTO 110
        CALL PBSTR(TOKEN)
        CALL OUTTAB
        CALL EATUP
        CALL OUTDON
110     IF(GETTOK(TOKEN,80).NE.59)GOTO 120
        CALL OUTCON(LAB)
        GOTO 130
120     CALL PBSTR(TOKEN)
        CALL OUTNUM(LAB)
        CALL OUTTAB
        CALL OUTSTR(IFNOT)
        CALL OUTCH(40)
        NLPAR=0
140     IF(NLPAR.LT.0)GOTO 150
        T=GETTOK(TOKEN,80)
        IF(T.EQ.59)GOTO 150
        IF(T.EQ.40)NLPAR=NLPAR+1
        IF(T.EQ.41)NLPAR=NLPAR-1
        IF(T.NE.10.AND.T.NE.95)CALL OUTSTR(TOKEN)
        GOTO 140
150     CALL OUTCH(41)
        CALL OUTCH(41)
        CALL OUTGO(LAB+2)
        IF(NLPAR.LT.0)CALL SYNERR('INVALID FOR CLAUSE.')
130     FORDEP=FORDEP+1
        J=1
        I=1
160     IF(I.GE.FORDEP)GOTO 170
        J=J+LENGTH(FORSTK(J))+1
        I=I+1
        GOTO 160
170     FORSTK(J)=0
        NLPAR=0
180     IF(NLPAR.LT.0)GOTO 190
        T=GETTOK(TOKEN,80)
        IF(T.EQ.40)NLPAR=NLPAR+1
        IF(T.EQ.41)NLPAR=NLPAR-1
        IF(.NOT.(NLPAR.GE.0.AND.T.NE.10.AND.T.NE.95))GOTO 180
        CALL SCOPY(TOKEN,1,FORSTK,J)
        J=J+LENGTH(TOKEN)
        GOTO 180
190     LAB=LAB+1
        RETURN
        END
        SUBROUTINE FORS(LAB)
C FORS - PROCESS END OF FOR STATEMENT
        INTEGER LENGTH
        INTEGER I,J,LAB
C
        INTEGER FORDEP
        INTEGER FORSTK
        COMMON /CFOR/FORDEP,FORSTK(100)
C
        CALL OUTNUM(LAB)
        J=1
        I=1
100     IF(I.GE.FORDEP)GOTO 110
        J=J+LENGTH(FORSTK(J))+1
        I=I+1
        GOTO 100
110     IF(LENGTH(FORSTK(J)).LE.0)GOTO 120
        CALL OUTTAB
        CALL OUTSTR(FORSTK(J))
        CALL OUTDON
120     CALL OUTGO(LAB-1)
        CALL OUTCON(LAB+1)
        FORDEP=FORDEP-1
        RETURN
        END
        INTEGER FUNCTION GETC(C)
C GETC - GETS CHARACTERS FROM INPUT FILE
        INTEGER BUF(81),C
        INTEGER I,J,LASTC
C
        INTEGER IPT
        COMMON /INFILE/IPT
        DATA LASTC/81/,BUF(81)/10/
C
        LASTC=LASTC+1
        IF(LASTC.LE.81)GOTO 100
        READ(IPT,9050,END=10)(BUF(I),I=1,80)
9050    FORMAT(80A1)
        LASTC=1
        J=0
        DO 1000 I=1,80
        CALL ILBYTE(BUF(I),BUF(I),0)
        IF(BUF(I).NE.32)J=I
1000    CONTINUE
        BUF(J+1)=10
100     CONTINUE
        C=BUF(LASTC)
        GETC=C
        IF(C.EQ.10)LASTC=81
        RETURN
10      C=-1
        GETC=-1
        RETURN
        END
        SUBROUTINE GETDEF(TOKEN,TOKSIZ,DEFN,DEFSIZ)
C GETDEF - GET NAME AND DEFINITION
        INTEGER GTOK,NGETC
        INTEGER DEFSIZ,I,NLPAR,TOKSIZ
        INTEGER C,DEFN(DEFSIZ),TOKEN(TOKSIZ)
C
        IF(NGETC(C).NE.40)CALL SYNERR('MISSING LEFT PARENTHESIS.')
        IF(GTOK(TOKEN,TOKSIZ).NE.65)
     $  CALL SYNERR('NON-ALPHANUMERIC NAME.')
        IF(NGETC(C).NE.44)CALL SYNERR('MISSING COMMA IN DEFINE.')
        NLPAR=0
        I=1
130     IF(NLPAR.LT.0)GOTO 131
        IF(I.GT.DEFSIZ)CALL SYNERR('DEFINITION TOO LONG.')
        IF(NGETC(DEFN(I)).EQ.-1)
     $  CALL SYNERR('MISSING RIGHT PARENTHESIS.')
        IF(DEFN(I).NE.40)GOTO 160
        NLPAR=NLPAR+1
        GOTO 141
160     IF(DEFN(I).EQ.41)NLPAR=NLPAR-1
141     I=I+1
        GOTO 130
131     DEFN(I-1)=0
        RETURN
        END
        INTEGER FUNCTION GETTOK(TOKEN,TOKSIZ)
C GETTOK - GETS TOKEN, INCLUDING MACRO REPLACEMENT
        INTEGER DEFTOK
        INTEGER TOKSIZ,TOKEN(80)
C
        GETTOK=DEFTOK(TOKEN,TOKSIZ)
        RETURN
        END
        INTEGER FUNCTION GTOK(LEXSTR,TOKSIZ)
C GTOK - GET TOKEN FOR RATFOR
        INTEGER NGETC,TYPE
        INTEGER I,TOKSIZ
        INTEGER C,LEXSTR(TOKSIZ)
C
        INTEGER LINECT
        COMMON /CLINE/LINECT
C
100     IF(NGETC(C).EQ.-1)GOTO 101
        IF(C.NE.32.AND.C.NE.9)GOTO 101
        GOTO 100
101     CALL PUTBAK(C)
        I=1
110     IF(I.GE.TOKSIZ-1)GOTO 111
        GTOK=TYPE(NGETC(LEXSTR(I)))
        IF(GTOK.NE.65.AND.GTOK.NE.48)GOTO 111
        I=I+1
        GOTO 110
111     IF(I.GE.TOKSIZ-1)CALL SYNERR('TOKEN TOO LONG.')
        IF(I.LE.1)GOTO 120
        CALL PUTBAK(LEXSTR(I))
        LEXSTR(I)=0
        CALL FOLD(LEXSTR)
        GTOK=65
        GOTO 121
120     IF(.NOT.(LEXSTR(1).EQ.39.OR.LEXSTR(I).EQ.34))GOTO 130
        I=2
140     IF(NGETC(LEXSTR(I)).EQ.LEXSTR(1))GOTO 141
        IF(.NOT.(LEXSTR(I).EQ.10.OR.I.GE.TOKSIZ-1))GOTO 150
        CALL SYNERR('MISSING QUOTE.')
        LEXSTR(I)=LEXSTR(1)
        CALL PUTBAK(10)
        GOTO 141
150     I=I+1
        GOTO 140
141     GOTO 131
130     IF(LEXSTR(1).NE.35)GOTO 160
170     IF(NGETC(LEXSTR(1)).EQ.10)GOTO 171
        GOTO 170
171     GTOK=10
160     IF(LEXSTR(1).EQ.61.OR.LEXSTR(1).EQ.60.OR.LEXSTR(1).EQ.62
     $  .OR.LEXSTR(1).EQ.124.OR.LEXSTR(1).EQ.33.OR.LEXSTR(1).EQ.38)
     $  CALL RELATE(LEXSTR,I)
131     CONTINUE
121     LEXSTR(I+1)=0
        IF(LEXSTR(1).EQ.10)LINECT=LINECT+1
        RETURN
        END
        SUBROUTINE IFCODE(LAB)
C IFCODE - GENERATE CODE FOR IF
        INTEGER LABGEN
        INTEGER LAB
C
        LAB=LABGEN(2)
        CALL IFGO(LAB)
        RETURN
        END
        SUBROUTINE IFGO(LAB)
C IFGO - GENERATE "IF(.NOT.(...))GOTO LAB
        INTEGER LAB
        INTEGER IFNOT(9)
        DATA IFNOT/73,70,40,46,78,79,84,46,0/
C
        CALL OUTTAB
        CALL OUTSTR(IFNOT)
        CALL BALPAR
        CALL OUTCH(41)
        CALL OUTGO(LAB)
        RETURN
        END
        SUBROUTINE INIT
C INIT - PERFORM NECESSARY HOUSEKEEPING BEFORE MAIN ROUTINE
        INTEGER IPT,OPT
        COMMON /INFILE/IPT
        COMMON /OFILE/OPT
        INTEGER LINECT
        COMMON /CLINE/LINECT
C
C CHANGE INPUT TO READ FROM FD 10
C CHANGE OUTPUT TO WRITE TO FD 6
C
        IPT=7
        OPT=6
        LINECT=1
        RETURN
        END
        SUBROUTINE INSTAL(NAME,DEFN)
C INSTAL - ADD NAME AND DEFINITION TO TABLE
        INTEGER NAME(80),DEFN(80)
        INTEGER LENGTH
        INTEGER DLEN,NLEN
C
        INTEGER LASTP,LASTT,NAMPTR,TABLE
        COMMON /CLOOK/LASTP,LASTT,NAMPTR(200),TABLE(4000)
C
        NLEN=LENGTH(NAME)+1
        DLEN=LENGTH(DEFN)+1
        IF(.NOT.(LASTT+NLEN+DLEN.GT.4000.OR.LASTP.GE.200))GOTO 100
        CALL REMARK('TOO MANY DEFINITIONS.')
        RETURN
100     LASTP=LASTP+1
        NAMPTR(LASTP)=LASTT+1
        CALL SCOPY(NAME,1,TABLE,LASTT+1)
        CALL SCOPY(DEFN,1,TABLE,LASTT+NLEN+1)
        LASTT=LASTT+NLEN+DLEN
        RETURN
        END
        INTEGER FUNCTION ITOA(INT,STR,SIZE)
C ITOA - CONVERT INTEGER INT TO CHAR STR IN STR
        INTEGER IABS,MOD
        INTEGER D,I,INT,INTVAL,J,K,SIZE
        INTEGER STR(SIZE)
        INTEGER DIGITS(10)
        DATA DIGITS/48,49,50,51,52,53,54,55,56,57/
C
        INTVAL=IABS(INT)
        STR(1)=0
        I=1
100     I=I+1
        D=MOD(INTVAL,10)
        STR(I)=DIGITS(D+1)
        INTVAL=INTVAL/10
        IF(INTVAL.NE.0.AND.I.LT.SIZE)GOTO 100
        IF(.NOT.(INT.LT.0.AND.I.LT.SIZE))GOTO 110
        I=I+1
        STR(I)=45
110     ITOA=I-1
        J=1
120     IF(J.GE.I)GOTO 121
        K=STR(I)
        STR(I)=STR(J)
        STR(J)=K
        I=I-1
        J=J+1
        GOTO 120
121     RETURN
        END
        SUBROUTINE LABELC(LEXSTR)
C LABELC - OUTPUT STATEMENT NUMBER
        INTEGER LEXSTR(100)
        INTEGER LENGTH
C
        IF(LENGTH(LEXSTR).NE.5)GOTO 100
        IF(LEXSTR(1).EQ.50.AND.LEXSTR(2).EQ.51)
     $  CALL SYNERR('WARNING: POSSIBLE LABEL CONFLICT.')
100     CALL OUTSTR(LEXSTR)
        CALL OUTTAB
        RETURN
        END
        INTEGER FUNCTION LABGEN(N)
C LABGEN - GENERATE N CONSECUTIVE LABELS, RETURN FIRST ONE
        INTEGER LABEL,N
        DATA LABEL/23000/
C
        LABGEN=LABEL
        LABEL=LABEL+N
        RETURN
        END
        INTEGER FUNCTION LENGTH(STR)
C LENGTH - COMPUTE LENGTH OF STRING
        INTEGER STR(100)
C
        LENGTH=0
100     IF(STR(LENGTH+1).EQ.0)RETURN
        LENGTH=LENGTH+1
        GOTO 100
        END
        INTEGER FUNCTION LEX(LEXSTR)
C LEX - RETURN LEXICAL TYPE OF TOKEN
        INTEGER GETTOK
        INTEGER LEXSTR(80)
        INTEGER ALLDIG,EQUAL
        INTEGER SDO(3),SIF(3),SELSE(5),SBREAK(6),SNEXT(5),SFOR(4),
     $  SREPT(7),SUNTIL(6),SWHILE(6),SDEF(7)
C
        DATA SDO/68,79,0/
        DATA SIF/73,70,0/
        DATA SELSE/69,76,83,69,0/
        DATA SBREAK/66,82,69,65,75,0/
        DATA SNEXT/78,69,88,84,0/
        DATA SFOR/70,79,82,0/
        DATA SREPT/82,69,80,69,65,84,0/
        DATA SUNTIL/85,78,84,73,76,0/
        DATA SWHILE/87,72,73,76,69,0/
        DATA SDEF/68,69,70,73,78,69,0/
C
100     IF(GETTOK(LEXSTR,80).NE.10)GOTO 101
        GOTO 100
101     LEX=LEXSTR(1)
        IF(LEX.EQ.-1.OR.LEX.EQ.59.OR.LEX.EQ.123.OR.LEX.EQ.125)RETURN
        IF(ALLDIG(LEXSTR).EQ.0)GOTO 120
        LEX=-9
        RETURN
120     IF(EQUAL(LEXSTR,SIF).EQ.0)GOTO 130
        LEX=-12
        RETURN
130     IF(EQUAL(LEXSTR,SELSE).EQ.0)GOTO 140
        LEX=-11
        RETURN
140     IF(EQUAL(LEXSTR,SWHILE).EQ.0)GOTO 150
        LEX=-15
        RETURN
150     IF(EQUAL(LEXSTR,SDO).EQ.0)GOTO 160
        LEX=-10
        RETURN
160     IF(EQUAL(LEXSTR,SBREAK).EQ.0)GOTO 170
        LEX=-8
        RETURN
170     IF(EQUAL(LEXSTR,SNEXT).EQ.0)GOTO 180
        LEX=-13
        RETURN
180     IF(EQUAL(LEXSTR,SFOR).EQ.0)GOTO 190
        LEX=-16
        RETURN
190     IF(EQUAL(LEXSTR,SREPT).EQ.0)GOTO 200
        LEX=-17
        RETURN
200     IF(EQUAL(LEXSTR,SUNTIL).EQ.0)GOTO 210
        LEX=-18
        RETURN
210     IF(EQUAL(LEXSTR,SDEF).EQ.0)GOTO 220
        LEX=-4
        RETURN
220     LEX=-14
        RETURN
        END
        INTEGER FUNCTION LOOKUP(NAME,DEFN)
C LOOKUP - LOCATE NAME, EXTRACT DEFINITION FROM TABLE
        INTEGER DEFN(80),NAME(80)
        INTEGER I,J,K
C
        INTEGER LASTP
        INTEGER LASTT
        INTEGER NAMPTR
        INTEGER TABLE
        COMMON /CLOOK/LASTP,LASTT,NAMPTR(200),TABLE(4000)
C
        I=LASTP
100     IF(I.LE.0)GOTO 101
        J=NAMPTR(I)
        K=1
110     IF(.NOT.(NAME(K).EQ.TABLE(J).AND.NAME(K).NE.0))GOTO 111
        J=J+1
        K=K+1
        GOTO 110
111     IF(NAME(K).NE.TABLE(J))GOTO 130
        CALL SCOPY(TABLE,J+1,DEFN,1)
        LOOKUP=1
        RETURN
130     I=I-1
        GOTO 100
101     LOOKUP=0
        RETURN
        END
        INTEGER FUNCTION NGETC(C)
C NGETC - GET A (POSSIBLY PUSHED BACK) CHARACTER
        INTEGER GETC
        INTEGER C
C
        INTEGER BP
        INTEGER BUF
        COMMON /CDEFIO/BP,BUF(100)
C
        IF(BP.LE.0)GOTO 100
        C=BUF(BP)
        GOTO 101
100     BP=1
        BUF(BP)=GETC(C)
101     BP=BP-1
        NGETC=C
        RETURN
        END
        SUBROUTINE OTHERC(LEXSTR)
C OTHERC - OUTPUT ORDINARY FORTRAN STATEMENT
        INTEGER LEXSTR(100)
C
        CALL OUTTAB
        CALL OUTSTR(LEXSTR)
        CALL OUTCH(32)
        CALL EATUP
        CALL OUTDON
        RETURN
        END
        SUBROUTINE OUTCH(C)
C OUTCH - PUT ONE CHARACTER IN OUTPUT BUFFER
        INTEGER C
        INTEGER I
C
        INTEGER OUTP
        INTEGER OUTBUF
        COMMON /COUTLN/OUTP,OUTBUF(81)
C
        IF(OUTP.LT.72)GOTO 100
        CALL OUTDON
        I=1
110     IF(I.GE.6)GOTO 111
        OUTBUF(I)=32
        I=I+1
        GOTO 110
111     OUTBUF(6)=36
        OUTP=6
100     OUTP=OUTP+1
        OUTBUF(OUTP)=C
        RETURN
        END
        SUBROUTINE OUTCON(N)
C OUTCON - OUTPUT "N CONTINUE"
        INTEGER N
        INTEGER CONTIN(9)
        DATA CONTIN/67,79,78,84,73,78,85,69,0/
C
        IF(N.GT.0)CALL OUTNUM(N)
        CALL OUTTAB
        CALL OUTSTR(CONTIN)
        CALL OUTDON
        RETURN
        END
        SUBROUTINE OUTDON
C OUTDON - FINISH OFF AN OUTPUT LINE
        INTEGER OUTP
        INTEGER OUTBUF
        COMMON /COUTLN/OUTP,OUTBUF(81)
C
        OUTBUF(OUTP+1)=10
        OUTBUF(OUTP+2)=0
        CALL PUTLIN(OUTBUF)
        OUTP=0
        RETURN
        END
        SUBROUTINE OUTGO(N)
C OUTGO - OUTPUT "GOTO N"
        INTEGER N
        INTEGER GOTO(6)
        DATA GOTO/71,79,84,79,32,0/
C
        CALL OUTTAB
        CALL OUTSTR(GOTO)
        CALL OUTNUM(N)
        CALL OUTDON
        RETURN
        END
        SUBROUTINE OUTNUM(N)
C OUTNUM - OUTPUT DECIMAL NUMBER
        INTEGER CHARS(10)
        INTEGER ITOA
        INTEGER I,LEN,N
C
        LEN=ITOA(N,CHARS,10)
        I=1
100     IF(I.GT.LEN)GOTO 101
        CALL OUTCH(CHARS(I))
        I=I+1
        GOTO 100
101     RETURN
        END
        SUBROUTINE OUTSTR(STR)
C OUTSTR - OUTPUT STRING
        INTEGER C,STR(100)
        INTEGER I
C
        I=1
100     IF(STR(I).EQ.0)RETURN
        C=STR(I)
        CALL OUTCH(C)
        I=I+1
        GOTO 100
        END
        SUBROUTINE OUTTAB
C OUTTAB - GET PAST COLUMN 6
        INTEGER OUTP
        INTEGER OUTBUF
        COMMON /COUTLN/OUTP,OUTBUF(81)
C
100     IF(OUTP.GE.6)RETURN
        CALL OUTCH(32)
        GOTO 100
        END
        SUBROUTINE PARSE
C PARSE - PARSE RATFOR PROGRAM
        INTEGER LEXSTR(80),DEFN(80)
        INTEGER LEX
        INTEGER LAB,LABVAL(50),LEXTYP(50),SP,TOKEN
C
        SP=1
        LEXTYP(1)=-1
        TOKEN=LEX(LEXSTR)
100     IF(TOKEN.EQ.-1)GOTO 101
        IF(TOKEN.NE.-12)GOTO 110
        CALL IFCODE(LAB)
        GOTO 111
110     IF(TOKEN.NE.-10)GOTO 120
        CALL DOCODE(LAB)
        GOTO 121
120     IF(TOKEN.NE.-15)GOTO 130
        CALL WHILEC(LAB)
        GOTO 131
130     IF(TOKEN.NE.-16)GOTO 132
        CALL FORCOD(LAB)
        GOTO 131
132     IF(TOKEN.NE.-17)GOTO 133
        CALL REPCOD(LAB)
        GOTO 131
133     IF(TOKEN.NE.-9)GOTO 140
        CALL LABELC(LEXSTR)
        GOTO 141
140     IF(TOKEN.NE.-11)GOTO 141
        IF(LEXTYP(SP).NE.-12)GOTO 160
        CALL ELSEIF(LABVAL(SP))
        GOTO 131
160     CALL SYNERR('ILLEGAL ELSE.')
141     CONTINUE
131     CONTINUE
121     CONTINUE
111     CONTINUE
        IF(.NOT.(TOKEN.EQ.-12.OR.TOKEN.EQ.-11.OR.TOKEN.EQ.-15
     $  .OR.TOKEN.EQ.-10.OR.TOKEN.EQ.-16.OR.TOKEN.EQ.-17
     $  .OR.TOKEN.EQ.-9.OR.TOKEN.EQ.123))GOTO 170
        SP=SP+1
        IF(SP.GT.50)CALL ERROR('STACK OVERFLOW IN PARSER.')
        LEXTYP(SP)=TOKEN
        LABVAL(SP)=LAB
        GOTO 171
170     IF(TOKEN.NE.125)GOTO 180
        IF(LEXTYP(SP).NE.123)GOTO 190
        SP=SP-1
        GOTO 191
190     CALL SYNERR('ILLEGAL RIGHT BRACE.')
191     CONTINUE
        GOTO 181
180     IF(TOKEN.NE.-4)GOTO 182
        CALL GETDEF(LEXSTR,80,DEFN,80)
        CALL INSTAL(LEXSTR,DEFN)
        GOTO 201
182     IF(TOKEN.NE.-14)GOTO 200
        CALL OTHERC(LEXSTR)
        GOTO 201
200     IF(TOKEN.EQ.-8.OR.TOKEN.EQ.-13)
     $  CALL BRKNXT(SP,LEXTYP,LABVAL,TOKEN)
201     CONTINUE
181     CONTINUE
        TOKEN=LEX(LEXSTR)
        CALL PBSTR(LEXSTR)
        CALL UNSTAK(SP,LEXTYP,LABVAL,TOKEN)
171     CONTINUE
        TOKEN=LEX(LEXSTR)
        GOTO 100
101     CONTINUE
        IF(SP.NE.1)CALL SYNERR('UNEXPECTED EOF.')
        RETURN
        END
        SUBROUTINE PBSTR(IN)
C PBSTR - PUSH STRING BACK ONTO INPUT
        INTEGER IN(81)
        INTEGER LENGTH
        INTEGER I
C
        I=LENGTH(IN)
100     IF(I.LE.0)GOTO 101
        CALL PUTBAK(IN(I))
        I=I-1
        GOTO 100
101     RETURN
        END
        SUBROUTINE PUTBAK(C)
C PUTBAK - PUSH BACK CHARACTER ONTO INPUT
        INTEGER C
C
        INTEGER BP
        INTEGER BUF
        COMMON /CDEFIO/BP,BUF(100)
C
        BP=BP+1
        IF(BP.GT.100)CALL ERROR('TOO MANY CHARACTERS PUSHED BACK.')
        BUF(BP)=C
        RETURN
        END
        SUBROUTINE PUTC(C)
C PUTC - PUTS CHARACTER ON OUTPUT UNIT
        INTEGER BUF(80),C
        INTEGER I,LASTC
C
        INTEGER OPT
        COMMON /OFILE/OPT
C
        DATA LASTC/0/
C
        IF(.NOT.(LASTC.GT.80.OR.C.EQ.10))GOTO 100
        IF(LASTC.NE.0)GOTO 110
        LASTC=1
        BUF(1)=32
110     DO 1000 I=1,LASTC
        CALL ISBYTE(BUF(I),BUF(I),0)
1000    CONTINUE
        WRITE(OPT,9060)(BUF(I),I=1,LASTC)
9060    FORMAT(80A1)
        LASTC=0
100     IF(C.EQ.10)GOTO 120
        LASTC=LASTC+1
        BUF(LASTC)=C
120     RETURN
        END
        SUBROUTINE PUTLIN(LINE)
C PUTLIN - PUTS A LINE ON OUTPUT UNIT
        INTEGER LINE(80)
        INTEGER I
C
        I=1
100     IF(LINE(I).EQ.0)RETURN
        CALL PUTC(LINE(I))
        I=I+1
        GOTO 100
        END
        SUBROUTINE RELATE(TOKEN,LAST)
C RELATE - CONVERTS SYMBOLIC RELATIONALS TO ALPHA ABBREVIATIONS
        INTEGER NGETC
        INTEGER TOKEN(80),T
        INTEGER LENGTH
        INTEGER LAST
        INTEGER DOTAND(6),DOTEQ(5),DOTGE(5),DOTGT(5)
        INTEGER DOTLE(5),DOTLT(5),DOTNE(5),DOTNOT(6),DOTOR(5)
C
        DATA DOTAND/46,65,78,68,46,0/
        DATA DOTEQ/46,69,81,46,0/
        DATA DOTGE/46,71,69,46,0/
        DATA DOTGT/46,71,84,46,0/
        DATA DOTLE/46,76,69,46,0/
        DATA DOTLT/46,76,84,46,0/
        DATA DOTNE/46,78,69,46,0/
        DATA DOTNOT/46,78,79,84,46,0/
        DATA DOTOR/46,79,82,46,0/
C
        T=NGETC(TOKEN(2))
        IF(T.NE.60.AND.T.NE.61.AND.T.NE.62)CALL PUTBAK(TOKEN(2))
        IF(TOKEN(1).NE.61)GOTO 100
        IF(TOKEN(2).NE.61)GOTO 110
        CALL SCOPY(DOTEQ,1,TOKEN,1)
        GOTO 300
110     TOKEN(2)=0
        GOTO 300
100     IF(TOKEN(1).NE.33)GOTO 130
        IF(TOKEN(2).NE.61)GOTO 140
        CALL SCOPY(DOTNE,1,TOKEN,1)
        GOTO 300
140     IF(TOKEN(2).NE.60)GOTO 141
        CALL SCOPY(DOTGE,1,TOKEN,1)
        GOTO 300
141     IF(TOKEN(2).NE.62)GOTO 142
        CALL SCOPY(DOTLE,1,TOKEN,1)
        GOTO 300
142     CALL SCOPY(DOTNOT,1,TOKEN,1)
        GOTO 300
130     IF(TOKEN(1).NE.60)GOTO 160
        IF(TOKEN(2).NE.61)GOTO 170
        CALL SCOPY(DOTLE,1,TOKEN,1)
        GOTO 300
170     CALL SCOPY(DOTLT,1,TOKEN,1)
        GOTO 300
160     IF(TOKEN(1).NE.62)GOTO 190
        IF(TOKEN(2).NE.61)GOTO 200
        CALL SCOPY(DOTGE,1,TOKEN,1)
        GOTO 300
200     CALL SCOPY(DOTGT,1,TOKEN,1)
        GOTO 300
190     IF(TOKEN(1).NE.38)GOTO 220
        CALL SCOPY(DOTAND,1,TOKEN,1)
        GOTO 300
220     IF(TOKEN(1).NE.124)GOTO 240
        CALL SCOPY(DOTOR,1,TOKEN,1)
        GOTO 300
240     TOKEN(2)=0
300     LAST=LENGTH(TOKEN)
        RETURN
        END
        SUBROUTINE REMARK(MSG)
C REMARK - PRINTS MESSAGE ON STANDARD OUTPUT UNIT
        CHARACTER*(*) MSG
C
        WRITE(5,9050)MSG
9050    FORMAT(1X,A)
        RETURN
        END
        SUBROUTINE REPCOD(LAB)
C REPCOD - GENERATE CODE FOR BEGINNING OF REPEAT
        INTEGER LABGEN
        INTEGER LAB
C
        CALL OUTCON(0)
        LAB=LABGEN(3)
        CALL OUTCON(LAB)
        LAB=LAB+1
        RETURN
        END
        SUBROUTINE SCOPY(FROM,I,TO,J)
C SCOPY - COPY STRING AT FROM(I) TO TO(J)
        INTEGER FROM(100),TO(100)
        INTEGER I,J,K1,K2
C
C
        K2=J
        K1=I
100     IF(FROM(K1).EQ.0)GOTO 101
        TO(K2)=FROM(K1)
        K2=K2+1
        K1=K1+1
        GOTO 100
101     TO(K2)=0
        RETURN
        END
        SUBROUTINE SYNERR(MSG)
        CHARACTER*(*) MSG
C
        INTEGER LINECT
        COMMON /CLINE/LINECT
C
        WRITE(5,9050)LINECT,MSG
9050    FORMAT(1X,I4,': ',A)
        RETURN
        END
        INTEGER FUNCTION TYPE(C)
C TYPE - DETERMINES TYPE OF CHARACTER
        INTEGER C
C
        TYPE=C
        IF((C.GE.65.AND.C.LE.90).OR.(C.GE.97.AND.C.LE.122))TYPE=65
        IF(C.GE.48.AND.C.LE.57)TYPE=48
        RETURN
        END
        SUBROUTINE UNSTAK(SP,LEXTYP,LABVAL,TOKEN)
C UNSTAK - UNSTACK AT END OF STATEMENT
        INTEGER LABVAL(50),LEXTYP(50),SP,TOKEN
C
100     IF(SP.LE.1)GOTO 101
        IF(LEXTYP(SP).EQ.123)GOTO 101
        IF(LEXTYP(SP).EQ.-12.AND.TOKEN.EQ.-11)GOTO 101
        IF(LEXTYP(SP).NE.-12)GOTO 110
        CALL OUTCON(LABVAL(SP))
        GOTO 111
110     IF(LEXTYP(SP).NE.-11)GOTO 120
        IF(SP.GT.2)SP=SP-1
        CALL OUTCON(LABVAL(SP)+1)
        GOTO 121
120     IF(LEXTYP(SP).NE.-10)GOTO 130
        CALL DOSTAT(LABVAL(SP))
        GOTO 131
130     IF(LEXTYP(SP).NE.-15)GOTO 140
        CALL WHILES(LABVAL(SP))
        GOTO 131
140     IF(LEXTYP(SP).NE.-16)GOTO 150
        CALL FORS(LABVAL(SP))
        GOTO 131
150     IF(LEXTYP(SP).EQ.-17)CALL UNTILS(LABVAL(SP),TOKEN)
131     CONTINUE
121     CONTINUE
111     CONTINUE
        SP=SP-1
        GOTO 100
101     RETURN
        END
        SUBROUTINE UNTILS(LAB,TOKEN)
C UNTILS - GENERATE CODE FOR UNTIL OR END OF REPEAT
        INTEGER PTOKEN(80)
        INTEGER LEX
        INTEGER JUNK,LAB,TOKEN
C
        CALL OUTNUM(LAB)
        IF(TOKEN.NE.-18)GOTO 100
        JUNK=LEX(PTOKEN)
        CALL IFGO(LAB-1)
        GOTO 110
100     CALL OUTGO(LAB-1)
110     CALL OUTCON(LAB+1)
        RETURN
        END
        SUBROUTINE WHILEC(LAB)
C WHILEC - GENERATE CODE FOR BEGINNING OF WHILE
        INTEGER LABGEN
        INTEGER LAB
C
        CALL OUTCON(0)
        LAB=LABGEN(2)
        CALL OUTNUM(LAB)
        CALL IFGO(LAB+1)
        RETURN
        END
        SUBROUTINE WHILES(LAB)
C WHILES - GENERATE CODE FOR END OF WHILE
        INTEGER LAB
C
        CALL OUTGO(LAB)
        CALL OUTCON(LAB+1)
        RETURN
        END
        BLOCKDATA
        INTEGER LINECT
        COMMON /CLINE/LINECT
        INTEGER BP
        INTEGER BUF
        COMMON /CDEFIO/BP,BUF(100)
        DATA BP/0/
        INTEGER OUTP
        INTEGER OUTBUF
        COMMON /COUTLN/OUTP,OUTBUF(81)
        DATA OUTP/0/
        INTEGER LASTP,LASTT,NAMPTR,TABLE
        COMMON /CLOOK/LASTP,LASTT,NAMPTR(200),TABLE(4000)
        DATA LASTP/0/,LASTT/0/
        INTEGER FORDEP
        INTEGER FORSTK
        COMMON /CFOR/FORDEP,FORSTK(100)
        DATA FORDEP/0/
        END
