# include definition files
   include "libdef.i"
#-h-  amove          639  local  09/22/80  15:38:30
# amove - move name1 to name2
   # VMS version - cheat, use DCL to rename file

   integer function amove (name1, name2)
   character name1 (ARB), name2 (ARB)

   CHARACTER*FILENAMESIZE oldnam, newnam
   integer olen, nlen
   integer ctos

   olen = ctos (name1, oldnam)
   nlen = ctos (name2, newnam)
   if (!lib$spawn ('ren ' // oldnam(1:olen) // ' ' // newnam(1:nlen) ) )
      return (ERR)
   else
      return (OK)
   end
#-t-  amove          639  local  09/22/80  15:38:30
#-h-  fcopy          218  local  09/22/80  15:38:32
# fcopy - copy file in to file out

   subroutine fcopy (in, out)
   filedes in, out

   character line (MAXLINE)

   integer getlin

   while (getlin (line, in) != EOF)
      call putlin (line, out)

   return
   end
#-t-  fcopy          218  local  09/22/80  15:38:32
#-h-  getc          147  local  09/22/80  15:38:33
# getc - get character from STDIN

   character function getc (c)
   character c

   character getch

   getc = getch (c, STDIN)

   return
   end
#-t-  getc          147  local  09/22/80  15:38:33
#-h-  getnow          587  local  09/22/80  15:38:33
# getnow - return current time and date
   # VMS version

   subroutine getnow (now)
   integer now (7)

   integer sec
   real secnds

   call idate (now(2), now(3), now(1))
#  now (1) = 80                     # the year
#  now (2) = 9                      # the month
#  now (3) = 30                     # the day of the month
   sec = ifix (secnds(0.0))
   now (4) = sec / 3600
   now (5) = mod (sec, 3600) / 60
   now (6) = mod (sec, 60)
   now (7) = 0
#  now (4) = 23                     # the hour of the day (24-hour clock)
#  now (5) = 59                     # the minute of the hour
#  now (6) = 59                     # the second of the minute
#  now (7) = 999                    # the millisecond of the second

   # values unobtainable on your system may default to zero

   return
   end
#-t-  getnow          587  local  09/22/80  15:38:33
#-h-  gfnarg         3400  local  09/22/80  15:38:34
# gfnarg --- get the next file name from the argument list

   integer function gfnarg (name, state)
   character name (ARB)
   integer state (4)

   integer l
   integer getarg, getlin, length

   filedes fd
   filedes open

   string in1 "stdin1"
   string in2 "stdin2"
   string in3 "stdin3"

   repeat {

      if (state (1) == 1) {
         state (1) = 2        # new state
         state (2) = 1        # next argument
         state (3) = ERR      # current input file
         state (4) = 0        # input file count
         }

      else if (state (1) == 2) {
         if (getarg (state (2), name, MAXARG) != EOF) {
            state (1) = 2     # stay in same state
            state (2) = state (2) + 1  # bump argument count
            if (name (1) != MINUS) {
               state (4) = state (4) + 1    # bump input file count
               return (OK)
               }
            else if (name (2) == EOS) {
               call scopy (in1, 1, name, 1)
               state (4) = state (4) + 1    # bump input file count
               return (OK)
               }
            else if (name (2) == DIG1 & name (3) == EOS) {
               call scopy (in1, 1, name, 1)
               state (4) = state (4) + 1    # bump input file count
               return (OK)
               }
            else if (name (2) == DIG2 & name (3) == EOS) {
               call scopy (in2, 1, name, 1)
               state (4) = state (4) + 1    # bump input file count
               return (OK)
               }
            else if (name (2) == DIG3 & name (3) == EOS) {
               call scopy (in3, 1, name, 1)
               state (4) = state (4) + 1    # bump input file count
               return (OK)
               }

            else if (name (2) == LETN | name (2) == BIGN) {
               state (1) = 3           # new state
               if (name (3) == EOS)
                  state (3) = STDIN
               else if (name (3) == DIG1 & name (4) == EOS)
                  state (3) = STDIN1
               else if (name (3) == DIG2 & name (4) == EOS)
                  state (3) = STDIN2
               else if (name (3) == DIG3 & name (4) == EOS)
                  state (3) = STDIN3
               else {
                  state (3) = open (name (3), READ)
                  if (state (3) == ERR) {
                     call putlin (name, ERROUT)
                     call remark (":  can't open.")
                     state (1) = 2
                     }
                  }
               }
            else
               return (ERR)
            }

         else
            state (1) = 4     # EOF state
         }

      else if (state (1) == 3) {
         l = getlin (name, state (3))
         if (l != EOF) {
            name (l) = EOS
            state (4) = state (4) + 1  # bump input file count
            return (OK)
            }
         if (fd != ERR & fd != STDIN)
            call close (state (3))
         state (1) = 2
         }

      else if (state (1) == 4) {
         state (1) = 5
         if (state (4) == 0) {# no input files
            call scopy (in1, 1, name, 1)
            return (OK)
            }
         break
         }

      else if (state (1) == 5)
         break

      else
         call error ("in gfnarg:  bad state (1) value.")

      } # end of infinite repeat

   name (1) = EOS
   return (EOF)
   end
#-t-  gfnarg         3400  local  09/22/80  15:38:34
#-h-  initst         4393  local  09/22/80  15:38:36
# initst - initialize variables and I/O for software tools programs

   subroutine initst

   character input (FILENAMESIZE),
             output (FILENAMESIZE),
             errout (FILENAMESIZE),
             buf (MAXLINE)

   integer i, outacc, erracc
   integer getarg, insub, outsub, errsub

   filedes open, create

   # include args

 ## common block used to hold command line argument information
 # Put on a file called 'args'

 common /args/ nbrarg, ptr (MAXARGS), arg (ARGBUFSIZE)
 integer nbrarg         #number arguments in list; initialize to 0
 integer ptr            #pointers (into 'arg') for each argument
 character arg          #arguments stored as ascii strings terminated
                        #with EOS markers


   # include io

 ## io - common block holding I/O information for portable primitives
 # put on a file called 'io'

 common /io/  unit (MAXOFILES), lastc (MAXOFILES), ccnt (MAXOFILES),
              filacc (MAXOFILES), mode (MAXOFILES), ftype (MAXOFILES),
              filenm (FILENAMESIZE, MAXOFILES),
              buffer (MAXLINE, MAXOFILES)

    integer unit        # fortran unit number
    integer lastc       # pointer to last character in unit's buffer
    integer ccnt        # number characters read/written in file
                        # (used only by seek)
    integer filacc      # access used to open file
                        # (READ, WRITE, READWRITE, or APPEND)
    integer mode        # device mode (DISK or TERMINAL)
    integer ftype       # file type (LOCAL, ASCII, BINARY)
    character filenm    # file name associated with unit
    character buffer    # line buffer for unit



   # Set default output and errout access types (WRITE or APPEND)
   data outacc /WRITE/
   data erracc /WRITE/


   #----------------------------------------------------------------
   #
   #   These initializations are done with substitutions rather than
   #   data or block data statements to avoid the problem of block
   #   data programs.
   #
   #----------------------------------------------------------------

   # Initialize command line argument count
   # (Located in /args/)

   nbrarg = 0

   # Initialize fortran units for I/O
   # (These are located in the 'io' common block
   # Change these to units appropriate to your machine

   #                      This is ERROUT (1)
   unit (ERROUT) = ERROUTUNIT
   mode (ERROUT) = TERMINAL        # TERMINAL or DISK
   ftype (ERROUT) = LOCAL          # File type - LOCAL, ASCII, or BINARY

   #                      This is STDIN (2)
   unit (STDIN) = STDINUNIT
   mode (STDIN) = TERMINAL         # TERMINAL or DISK
   ftype (STDIN) = LOCAL           # File type - LOCAL, ASCII, or BINARY

   #                      This is STDOUT (3)
   unit (STDOUT) = STDOUTUNIT
   mode (STDOUT) = TERMINAL        # TERMINAL or DISK
   ftype (STDOUT) = LOCAL          # File type - LOCAL, ASCII, or BINARY

#  #                      Any unit is OK here
#  unit (4) = UNITA
#  mode (4) = DISK                 # TERMINAL or DISK
#  ftype (4) = LOCAL               # File type - LOCAL, ASCII, or BINARY
#  #                      This is UNITB (any unit)
#  unit (5) = UNITB
#  mode (5) = DISK                 # TERMINAL or DISK
#  ftype (5) = LOCAL               # File type - LOCAL, ASCII, or BINARY
#  #                      This is UNITC (any unit)
#  unit (6) = UNITC
#  mode (6) = DISK                 # TERMINAL or DISK
#  ftype (6) = LOCAL               # File type - LOCAL, ASCII, or BINARY

# assign all remaining units

   for (i = 4; i <= MAXOFILES; i = i + 1) {
      unit (i) = i - 4 + UNITA
      mode (i) = DISK
      ftype (i) = LOCAL
   }

   # initialize default standard files
   call termin (input)
   call trmout (output)
   call trmout (errout)

   # initialize /io/ common block variables
   for (i = 1; i <= MAXOFILES; i = i + 1)
          filenm (1, i) = EOS

   # set up list of command arguments
   call makarg

   # pick up file substitutions for standard files
   for (i=1; getarg (i, buf, MAXLINE) != EOF; ) {
      if (insub (buf, input) == YES |
       outsub (buf, output, outacc) == YES |
       errsub (buf, errout, erracc) == YES )
         call delarg (i)
      else
         i = i + 1
      }

   # open standard input, output, and errout files
   if (create (errout, erracc) == ERR)
      call endst    # can't print error message cause no ERROUT file
   if (open (input, READ) == ERR)
      call cant (input)
   if (create (output, outacc) == ERR)
      call cant (output)

   return
   end
#-t-  initst         4393  local  09/22/80  15:38:36
#-h-  isatty         1107  local  09/22/80  15:38:37
# isatty - determine if file is a teletype/CRT device

   integer function isatty (int)
   filedes int

   # include io

 ## io - common block holding I/O information for portable primitives
 # put on a file called 'io'

 common /io/  unit (MAXOFILES), lastc (MAXOFILES), ccnt (MAXOFILES),
              filacc (MAXOFILES), mode (MAXOFILES), ftype (MAXOFILES),
              filenm (FILENAMESIZE, MAXOFILES),
              buffer (MAXLINE, MAXOFILES)

    integer unit        # fortran unit number
    integer lastc       # pointer to last character in unit's buffer
    integer ccnt        # number characters read/written in file
                        # (used only by seek)
    integer filacc      # access used to open file
                        # (READ, WRITE, READWRITE, or APPEND)
    integer mode        # device mode (DISK or TERMINAL)
    integer ftype       # file type (LOCAL, ASCII, BINARY)
    character filenm    # file name associated with unit
    character buffer    # line buffer for unit


   if (mode (int) == TERMINAL)
      isatty = YES
   else
      isatty = NO

   return
   end
#-t-  isatty         1107  local  09/22/80  15:38:37
#-h-  mkuniq          330  local  09/22/80  15:38:38
# mkuniq - get scratch file name based on 'seed'

   subroutine mkuniq (seed, name)
   character seed (ARB), name (ARB)

   # Portable version - return 'seed' as scratch file name
   # In system-dependent version, append process ID or some other
   # unique identifier to 'seed'

   call scopy (seed, 1, name, 1)
   return
   end
#-t-  mkuniq          330  local  09/22/80  15:38:38
#-h-  note         1197  local  09/22/80  15:38:39
# note - determine current file position (i.e. place where next
#        record will be read/written

   subroutine note (int, offset)
   filedes int
   integer offset (2)

   # include io

 ## io - common block holding I/O information for portable primitives
 # put on a file called 'io'

 common /io/  unit (MAXOFILES), lastc (MAXOFILES), ccnt (MAXOFILES),
              filacc (MAXOFILES), mode (MAXOFILES), ftype (MAXOFILES),
              filenm (FILENAMESIZE, MAXOFILES),
              buffer (MAXLINE, MAXOFILES)

    integer unit        # fortran unit number
    integer lastc       # pointer to last character in unit's buffer
    integer ccnt        # number characters read/written in file
                        # (used only by seek)
    integer filacc      # access used to open file
                        # (READ, WRITE, READWRITE, or APPEND)
    integer mode        # device mode (DISK or TERMINAL)
    integer ftype       # file type (LOCAL, ASCII, BINARY)
    character filenm    # file name associated with unit
    character buffer    # line buffer for unit


   # Transportable version - assume 'offset' is a character count

   offset (1) = ccnt (int) + 1
   return
   end
#-t-  note         1197  local  09/22/80  15:38:39
#-h-  prompt                      302  local   01/06/81  16:14:45
# prompt - write to/read from teletype
   # VMS version

   subroutine prompt (str, buf, fd)
   character str(ARB), buf(ARB)
   filedes fd

   CHARACTER*MAXLINE prmbuf, iptbuf
   integer slen, ilen
   integer ctos, stoc

   slen = max (ctos (str, prmbuf), 1)
   call lib$get_command (iptbuf, prmbuf(1:slen), ilen)
   slen = stoc (iptbuf(1:ilen), buf)

   return
   end
#-t-  prompt                      302  local   01/06/81  16:14:45
#-h-  query          317  local  09/22/80  15:38:40
# query - print usage message if user has requested one

   subroutine query (mesg)
   character mesg (ARB)

   integer getarg

   character arg1 (3), arg2 (1)

   if (getarg (1, arg1, 3) != EOF & getarg (2, arg2, 1) == EOF)
      if (arg1 (1) == QMARK & arg1 (2) == EOS)
         call error (mesg)

   return
   end
#-t-  query          317  local  09/22/80  15:38:40
#-h-  readf          394  local  09/22/80  15:38:40
# readf - read 'n' bytes/words/whatever from file fd
   #  PORTABLE version - read 'n' characters

   integer function readf (buf, n, fd)
   character buf (ARB)
   integer n
   filedes fd

   character getch

   integer i

   for (i = 1; i <= n; i = i + 1)
      if (getch (buf (i), fd) == EOF) {
         buf (i) = EOS
         return (EOF)
         }

   buf (i) = EOS
   return (i-1)
   end
#-t-  readf          394  local  09/22/80  15:38:40
#-h-  seek         1308  local  09/22/80  15:38:41
# seek - move read/write pointer to location 'offset'
   # Portable version - assume offset applies to a character
   # count and locate from beginning of file


   subroutine seek (offset, int)
   integer offset (2), int

   character getch

   # include io

 ## io - common block holding I/O information for portable primitives
 # put on a file called 'io'

 common /io/  unit (MAXOFILES), lastc (MAXOFILES), ccnt (MAXOFILES),
              filacc (MAXOFILES), mode (MAXOFILES), ftype (MAXOFILES),
              filenm (FILENAMESIZE, MAXOFILES),
              buffer (MAXLINE, MAXOFILES)

    integer unit        # fortran unit number
    integer lastc       # pointer to last character in unit's buffer
    integer ccnt        # number characters read/written in file
                        # (used only by seek)
    integer filacc      # access used to open file
                        # (READ, WRITE, READWRITE, or APPEND)
    integer mode        # device mode (DISK or TERMINAL)
    integer ftype       # file type (LOCAL, ASCII, BINARY)
    character filenm    # file name associated with unit
    character buffer    # line buffer for unit

   character c

   if (offset (1) <= ccnt (int))
      call rwind (int)
   while (ccnt (int) + 1 < offset (1))
      if (getch (c, int) == EOF)
         break

   return
   end
#-t-  seek         1308  local  09/22/80  15:38:41
#-h-  writef          347  local  09/22/80  15:38:44
# writef - write 'n' bytes/words/whatever to file fd
   #  PORTABLE version - write 'n' characters

   integer function writef (buf, n, fd)
   character buf (ARB)
   integer n
   filedes fd

   integer i

   for (i = 1; i <= n; i = i + 1) {
      if (buf (i) == EOS)
         break
      call putch (buf (i), fd)
      }

   return (i - 1)
   end
#-t-  writef          347  local  09/22/80  15:38:44
#-h-  remove          247  local  09/22/80  15:38:44
# remove - remove a file from the file system
   # VMS version

   integer function remove (file)
   character file (ARB)

   CHARACTER*FILENAMESIZE fname
   integer i
   integer ctos

   i = ctos (file, fname)
   open (99, file=fname(1:i), status='old', iostat=i)
   if (i == 0) {
      close (99, dispose='delete', iostat=i)
      if (i == 0)
         return (OK)
      }
   else
       return (ERR)
   end
#-t-  remove          247  local  09/22/80  15:38:44
#-h-  create         1195  local  09/22/80  15:38:44
# create - associate filename with internal specifier; create file
   # VMS version

   filedes function create (name, access)
   character name (ARB)
   integer access

   integer i, status, fnlen
   CHARACTER*FILENAMESIZE fname
   integer ctos
   filedes assign

   # include io

 ## io - common block holding I/O information for portable primitives
 # put on a file called 'io'

 common /io/  unit (MAXOFILES), lastc (MAXOFILES), ccnt (MAXOFILES),
              filacc (MAXOFILES), mode (MAXOFILES), ftype (MAXOFILES),
              filenm (FILENAMESIZE, MAXOFILES),
              buffer (MAXLINE, MAXOFILES)

    integer unit        # fortran unit number
    integer lastc       # pointer to last character in unit's buffer
    integer ccnt        # number characters read/written in file
                        # (used only by seek)
    integer filacc      # access used to open file
                        # (READ, WRITE, READWRITE, or APPEND)
    integer mode        # device mode (DISK or TERMINAL)
    integer ftype       # file type (LOCAL, ASCII, BINARY)
    character filenm    # file name associated with unit
    character buffer    # line buffer for unit

   for (i = 1; i <= MAXOFILES; i = i + 1)    # locate an unused unit
      if (filenm (1, i) == EOS)
         break
   if (i > MAXOFILES)                        # no space left
      return (ERR)
   fnlen = ctos (name, fname)
   if (access == APPEND)
      open (unit(i), file=fname(1:fnlen), status='unknown', access='append',
         recl=MAXLINE, carriagecontrol='list', iostat=status)
   else
      open (unit(i), file=fname(1:fnlen), status='unknown',
         recl=MAXLINE, carriagecontrol='list', iostat=status)
   if (status != 0)
      return (ERR)
   return (assign (name, i, access))

   end
#-t-  create         1195  local  09/22/80  15:38:44
#-h-  cant          502  local  09/22/80  15:38:46
# cant - print "file:  can't open" and terminate execution

   subroutine cant (file)
   character file (ARB)

   # string msg ":  can't open"
   character msg(15)
   data msg(1), msg(2), msg(3), msg(4), msg(5), msg(6), msg(7),
      msg(8), msg(9), msg(10), msg(11), msg(12), msg(13), msg(14),
      msg(15) /COLON, BLANK, BLANK,
      LETC, LETA, LETN, SQUOTE, LETT, BLANK,
      LETO, LETP, LETE, LETN, NEWLINE, EOS/

   call putlin (file, ERROUT)
   call putlin (msg, ERROUT)
   call endst

   end
#-t-  cant          502  local  09/22/80  15:38:46
#-h-  delarg          727  local  09/22/80  15:38:46
# delarg - delete reference to specified command line argument

   subroutine delarg (n)
   integer n

   # include args

 ## common block used to hold command line argument information
 # Put on a file called 'args'

 common /args/ nbrarg, ptr (MAXARGS), arg (ARGBUFSIZE)
 integer nbrarg         #number arguments in list; initialize to 0
 integer ptr            #pointers (into 'arg') for each argument
 character arg          #arguments stored as ascii strings terminated
                        #with EOS markers

   integer i

   if (n > nbrarg)        #check for valid argument
      return

   for (i = n; i < nbrarg; i = i + 1)  # rearrange pointers
      ptr (i) = ptr (i + 1)

   nbrarg = nbrarg - 1
   return
   end
#-t-  delarg          727  local  09/22/80  15:38:46
#-h-  errsub          497  local  09/22/80  15:38:46
# errsub - see if argument is ERROUT substitution

   integer function errsub (arg, file, access)

   character arg (ARB), file (ARB)
   integer access

   if (arg (1) == QMARK & arg (2) != QMARK & arg (2) != EOS) {
      errsub = YES
      access = WRITE
      call scopy (arg, 2, file, 1)
      }

   else if (arg (1) == QMARK & arg (2) == QMARK & arg (3) != EOS) {
      errsub = YES
      access = APPEND
      call scopy (arg, 3, file, 1)
      }

   else
      errsub = NO

   return
   end
#-t-  errsub          497  local  09/22/80  15:38:46
#-h-  outsub          510  local  09/22/80  15:38:46
# outsub - determine if argument is STDOUT substitution

   integer function outsub (arg, file, access)
   character arg (ARB), file (ARB)
   integer access

   if (arg (1) == GREATER & arg (2) != GREATER & arg (2) != EOS) {
      outsub = YES
      access = WRITE
      call scopy (arg, 2, file, 1)
      }

   else if (arg (1) == GREATER & arg (2) == GREATER & arg (3) != EOS) {
      access = APPEND
      outsub = YES
      call scopy (arg, 3, file, 1)
      }

   else
      outsub = NO

   return
   end
#-t-  outsub          510  local  09/22/80  15:38:46
#-h-  insub          276  local  09/22/80  15:38:46
# insub - determine if argument is STDIN substitution

   integer function insub (arg, file)
   character arg (ARB), file (ARB)

   if (arg (1) == LESS & arg (2) != EOS) {
      insub = YES
      call scopy (arg, 2, file, 1)
      }
   else
      insub = NO

   return
   end
#-t-  insub          276  local  09/22/80  15:38:46
#-h-  makarg         2928  local  09/22/80  15:38:47
# makarg - get command line arguments from system/user
   # VMS version

   subroutine makarg

   # include args

 ## common block used to hold command line argument information
 # Put on a file called 'args'

 common /args/ nbrarg, ptr (MAXARGS), arg (ARGBUFSIZE)
 integer nbrarg         #number arguments in list; initialize to 0
 integer ptr            #pointers (into 'arg') for each argument
 character arg          #arguments stored as ascii strings terminated
                        #with EOS markers


   # include io

 ## io - common block holding I/O information for portable primitives
 # put on a file called 'io'

 common /io/  unit (MAXOFILES), lastc (MAXOFILES), ccnt (MAXOFILES),
              filacc (MAXOFILES), mode (MAXOFILES), ftype (MAXOFILES),
              filenm (FILENAMESIZE, MAXOFILES),
              buffer (MAXLINE, MAXOFILES)

    integer unit        # fortran unit number
    integer lastc       # pointer to last character in unit's buffer
    integer ccnt        # number characters read/written in file
                        # (used only by seek)
    integer filacc      # access used to open file
                        # (READ, WRITE, READWRITE, or APPEND)
    integer mode        # device mode (DISK or TERMINAL)
    integer ftype       # file type (LOCAL, ASCII, BINARY)
    character filenm    # file name associated with unit
    character buffer    # line buffer for unit


   integer index, tog, funit, i
   string arrow ">"

   nbrarg = 0

   # Read the command line arguments into the 'arg' array as
   # a single line terminated with an EOS.  The rest of this
   # code will unpack them (assuming they are separated by a blank).

   call getcmd (arg)
   if (arg(1) == EOS)
      call prompt(arrow, arg, STDIN)

   #  The rest of this code will separate the arguments with EOS
   #  markers (instead of blanks) and will strip off quote marks

   index = 1
   for (i = 1; i <= MAXARGS; i = i + 1) {
      if (index < ARGBUFSIZE)
         call skipbl (arg, index)
      if (index >= ARGBUFSIZE | arg (index) == EOS)
         break
      ptr (i) = index
      if (arg (index) == SQUOTE | arg (index) == DQUOTE) {
         ptr (i) = index+1
         tog = arg (index)
         index = index + 1
         while (arg (index) != tog & arg (index) != EOS)
            index = index + 1
         }
      else
         while (arg (index) != BLANK & arg (index) != EOS)
            index = index + 1
      arg (index) = EOS
      index = index + 1
      }

   nbrarg = i -1
   return
   end
#-t-  makarg         2928  local  09/22/80  15:38:47
#-h-  trmout          195  local  09/22/80  15:38:48
# trmout - pick up name of output channel to users teletype

   subroutine trmout (name)
   character name (ARB)

   string tname TERMINAL_OUT

   call scopy (tname, 1, name, 1)
   return
   end
#-t-  trmout          195  local  09/22/80  15:38:48
#-h-  termin          193  local  09/22/80  15:38:48
# termin - pick up name of input channel to users teletype

   subroutine termin (name)
   character name (ARB)

   string tname TERMINAL_IN

   call scopy (tname, 1, name, 1)
   return
   end
#-t-  termin          193  local  09/22/80  15:38:48
#-h-  flush         1236  local  09/22/80  15:38:49
# flush - flush output buffer of file 'fd'
   # PORTABLE version - simply output line

   subroutine flush (int)
   filedes int

   # include io

 ## io - common block holding I/O information for portable primitives
 # put on a file called 'io'

 common /io/  unit (MAXOFILES), lastc (MAXOFILES), ccnt (MAXOFILES),
              filacc (MAXOFILES), mode (MAXOFILES), ftype (MAXOFILES),
              filenm (FILENAMESIZE, MAXOFILES),
              buffer (MAXLINE, MAXOFILES)

    integer unit        # fortran unit number
    integer lastc       # pointer to last character in unit's buffer
    integer ccnt        # number characters read/written in file
                        # (used only by seek)
    integer filacc      # access used to open file
                        # (READ, WRITE, READWRITE, or APPEND)
    integer mode        # device mode (DISK or TERMINAL)
    integer ftype       # file type (LOCAL, ASCII, BINARY)
    character filenm    # file name associated with unit
    character buffer    # line buffer for unit


   if (filenm (1, int) == EOS)             # error, file not really open
      return
   if (lastc (int) > 0 & filacc (int) != READ)  # flush buffer
      call putch (NEWLINE,int)

   return
   end
#-t-  flush         1236  local  09/22/80  15:38:49
#-h-  putc          119  local  09/22/80  15:38:49
# putc - put character onto STDOUT

   subroutine putc (c)
   character c

   call putch (c, STDOUT)

   return
   end
#-t-  putc          119  local  09/22/80  15:38:49
#-h-  getarg          975  local  09/22/80  15:38:49
# getarg - get specified command line argument
   #  see the routine 'markarg' for storing the arguments in an array

   integer function getarg (n, array, maxsiz)
   integer n, maxsiz
   character array (maxsiz)

   # include args

 ## common block used to hold command line argument information
 # Put on a file called 'args'

 common /args/ nbrarg, ptr (MAXARGS), arg (ARGBUFSIZE)
 integer nbrarg         #number arguments in list; initialize to 0
 integer ptr            #pointers (into 'arg') for each argument
 character arg          #arguments stored as ascii strings terminated
                        #with EOS markers

   integer index, i

   if (n < 1 | n > nbrarg) {  # no argument 'n'
      array (1) = EOS
      getarg = EOF
      return
      }

   index = ptr (n)
   for (i = 1; i <= maxsiz; i = i + 1) {
      array (i) = arg (index)
      if (arg (index) == EOS)  break
      index = index + 1
      }
   array (i) = EOS
   getarg = i - 1

   return
   end
#-t-  getarg          975  local  09/22/80  15:38:49
#-h-  open         1407  local  09/22/80  15:38:51
# open - associate filename with internal specifier; attach file
   # VMS version

   filedes function open (name, access)
   character name (ARB)
   integer access

   integer i, fnlen, status
   CHARACTER*FILENAMESIZE fname

   integer ctos
   filedes assign

   # include io

 ## io - common block holding I/O information for portable primitives
 # put on a file called 'io'

 common /io/  unit (MAXOFILES), lastc (MAXOFILES), ccnt (MAXOFILES),
              filacc (MAXOFILES), mode (MAXOFILES), ftype (MAXOFILES),
              filenm (FILENAMESIZE, MAXOFILES),
              buffer (MAXLINE, MAXOFILES)

    integer unit        # fortran unit number
    integer lastc       # pointer to last character in unit's buffer
    integer ccnt        # number characters read/written in file
                        # (used only by seek)
    integer filacc      # access used to open file
                        # (READ, WRITE, READWRITE, or APPEND)
    integer mode        # device mode (DISK or TERMINAL)
    integer ftype       # file type (LOCAL, ASCII, BINARY)
    character filenm    # file name associated with unit
    character buffer    # line buffer for unit


   for (i = 1; i <= MAXOFILES; i = i + 1)    # locate an unused unit
      if (filenm (1, i) == EOS)
         break
   if (i > MAXOFILES)                        # no space left
      return (ERR)
   fnlen = ctos (name, fname)
   if (access == READ)
      open (unit(i), file=fname(1:fnlen), status='old',
         recl=MAXLINE, carriagecontrol='list', readonly, iostat=status)
   elif (access == APPEND)
      open (unit(i), file=fname(1:fnlen), status='old', access='append',
         recl=MAXLINE, carriagecontrol='list', iostat=status)
   else
      open (unit(i), file=fname(1:fnlen), status='old',
         recl=MAXLINE, carriagecontrol='list', iostat=status)
   if (status != 0)
      return (ERR)
   return (assign (name, i, access) )        # assign file to unit
   end
#-t-  open         1407  local  09/22/80  15:38:51
#-h-  getlin          456  local  09/22/80  15:38:53
# getlin - get line by repeated calls to getch

   integer function getlin (line, int)
   character line (MAXLINE)
   filedes int

   integer i

   character getch

   for (i = 1; i < MAXLINE; i = i + 1)
      if (getch (line (i), int) == NEWLINE) {
         line (i + 1) = EOS
         return (i)
         }
      else if (line (i) == EOF) {
         line (i) = EOS
         return (EOF)
         }

   line (MAXLINE) = EOS
   return (MAXLINE - 1)
   end
#-t-  getlin          456  local  09/22/80  15:38:53
#-h-  assign         1419  local  09/22/80  15:38:53
# assign - associate file with specified unit 'int'
   # VMS version

   filedes function assign (name, int, access)
   character name (ARB)
   integer int, access

   # include io

 ## io - common block holding I/O information for portable primitives
 # put on a file called 'io'

 common /io/  unit (MAXOFILES), lastc (MAXOFILES), ccnt (MAXOFILES),
              filacc (MAXOFILES), mode (MAXOFILES), ftype (MAXOFILES),
              filenm (FILENAMESIZE, MAXOFILES),
              buffer (MAXLINE, MAXOFILES)

    integer unit        # fortran unit number
    integer lastc       # pointer to last character in unit's buffer
    integer ccnt        # number characters read/written in file
                        # (used only by seek)
    integer filacc      # access used to open file
                        # (READ, WRITE, READWRITE, or APPEND)
    integer mode        # device mode (DISK or TERMINAL)
    integer ftype       # file type (LOCAL, ASCII, BINARY)
    character filenm    # file name associated with unit
    character buffer    # line buffer for unit


   if (int < 1 | int > MAXOFILES)
      assign = ERR
   else {
      call scopy (name, 1, filenm (1, int), 1)
      assign = int
      lastc (int) = 0
      ccnt (int) = 0
      filacc (int) = access
      }

#  if (mode (int) == DISK)
#     call rwind (int)                 # position file at beginning

   return
   end
#-t-  assign         1419  local  09/22/80  15:38:53
#-h-  error          144  local  09/22/80  15:38:54
# error - print message and terminate execution

   subroutine error (line)
   character line (ARB)

   call remark (line)
   call endst
   end
#-t-  error          144  local  09/22/80  15:38:54
#-h-  getch         1419  local  09/22/80  15:38:55
# getch - get characters from file f

   character function getch (c, int)
   character c
   filedes int

   integer f, n, count
   integer getr

   # include io

 ## io - common block holding I/O information for portable primitives
 # put on a file called 'io'

 common /io/  unit (MAXOFILES), lastc (MAXOFILES), ccnt (MAXOFILES),
              filacc (MAXOFILES), mode (MAXOFILES), ftype (MAXOFILES),
              filenm (FILENAMESIZE, MAXOFILES),
              buffer (MAXLINE, MAXOFILES)

    integer unit        # fortran unit number
    integer lastc       # pointer to last character in unit's buffer
    integer ccnt        # number characters read/written in file
                        # (used only by seek)
    integer filacc      # access used to open file
                        # (READ, WRITE, READWRITE, or APPEND)
    integer mode        # device mode (DISK or TERMINAL)
    integer ftype       # file type (LOCAL, ASCII, BINARY)
    character filenm    # file name associated with unit
    character buffer    # line buffer for unit


   n = lastc (int)

   if (n == 0 | buffer (n, int) == NEWLINE | n >= MAXLINE) {
      count = getr (unit (int), buffer (1, int), MAXCARD)
      if (count == EOF) {
         c = EOF
         return (EOF)
         }
      lastc (int) = 0
      }

   lastc (int) = lastc (int) + 1
   ccnt (int) = ccnt (int) + 1
   c = buffer (lastc (int), int)
   return (c)
   end
#-t-  getch         1419  local  09/22/80  15:38:55
#-h-  endst         1090  local  09/22/80  15:38:56
# endst -- close all files and terminate rat4 program

   subroutine endst

   # include io

 ## io - common block holding I/O information for portable primitives
 # put on a file called 'io'

 common /io/  unit (MAXOFILES), lastc (MAXOFILES), ccnt (MAXOFILES),
              filacc (MAXOFILES), mode (MAXOFILES), ftype (MAXOFILES),
              filenm (FILENAMESIZE, MAXOFILES),
              buffer (MAXLINE, MAXOFILES)

    integer unit        # fortran unit number
    integer lastc       # pointer to last character in unit's buffer
    integer ccnt        # number characters read/written in file
                        # (used only by seek)
    integer filacc      # access used to open file
                        # (READ, WRITE, READWRITE, or APPEND)
    integer mode        # device mode (DISK or TERMINAL)
    integer ftype       # file type (LOCAL, ASCII, BINARY)
    character filenm    # file name associated with unit
    character buffer    # line buffer for unit


   integer int

   for (int = 1; int <= MAXOFILES; int = int + 1)
      call close (int)

   call exit
   end
#-t-  endst         1090  local  09/22/80  15:38:56
#-h-  putlin          233  local  09/22/80  15:38:57
# putlin - put out line by repeated calls to putch

   subroutine putlin (line, int)
   character line (ARB)
   filedes int

   integer i

   for (i = 1; line (i) != EOS; i = i + 1)
      call putch (line (i), int)

   return
   end
#-t-  putlin          233  local  09/22/80  15:38:57
#-h-  remark         1395  local  09/22/80  15:38:57
# remark - print message; assure NEWLINE

   subroutine remark (line)
   character line (ARB)

   # include io

 ## io - common block holding I/O information for portable primitives
 # put on a file called 'io'

 common /io/  unit (MAXOFILES), lastc (MAXOFILES), ccnt (MAXOFILES),
              filacc (MAXOFILES), mode (MAXOFILES), ftype (MAXOFILES),
              filenm (FILENAMESIZE, MAXOFILES),
              buffer (MAXLINE, MAXOFILES)

    integer unit        # fortran unit number
    integer lastc       # pointer to last character in unit's buffer
    integer ccnt        # number characters read/written in file
                        # (used only by seek)
    integer filacc      # access used to open file
                        # (READ, WRITE, READWRITE, or APPEND)
    integer mode        # device mode (DISK or TERMINAL)
    integer ftype       # file type (LOCAL, ASCII, BINARY)
    character filenm    # file name associated with unit
    character buffer    # line buffer for unit

   call putlin (line, ERROUT)
   call putch (NEWLINE, ERROUT)

   return
   end
#-t-  remark         1395  local  09/22/80  15:38:57
#-h-  getr          821  local  09/22/80  15:38:57
# getr - get next record from unit f
   # Portable version (Fortran IO)

   integer function getr (f, buf, maxsiz)
   integer f, maxsiz
   character buf (ARB)

   integer i, len # use VAX Fortran record count

#----------------------------------------------------------------
#
# Alter this read statement if it is not standard on your system:
#
#----------------------------------------------------------------

   read (f, 1, end = 10) len, (buf (i), i = 1, len) # modified
1  format (q, MAXCARD a1)
   buf (len + 1) = NEWLINE  # mark end-of-line with NEWLINE character
   getr = i + 1
   return

10 continue
   getr = EOF
   return
   end
#-t-  getr          821  local  09/22/80  15:38:57
#-h-  close         1379  local  09/22/80  15:38:59
# close - close file associated with unit 'int'

   subroutine close (int)
   filedes int

   # include io

 ## io - common block holding I/O information for portable primitives
 # put on a file called 'io'

 common /io/  unit (MAXOFILES), lastc (MAXOFILES), ccnt (MAXOFILES),
              filacc (MAXOFILES), mode (MAXOFILES), ftype (MAXOFILES),
              filenm (FILENAMESIZE, MAXOFILES),
              buffer (MAXLINE, MAXOFILES)

    integer unit        # fortran unit number
    integer lastc       # pointer to last character in unit's buffer
    integer ccnt        # number characters read/written in file
                        # (used only by seek)
    integer filacc      # access used to open file
                        # (READ, WRITE, READWRITE, or APPEND)
    integer mode        # device mode (DISK or TERMINAL)
    integer ftype       # file type (LOCAL, ASCII, BINARY)
    character filenm    # file name associated with unit
    character buffer    # line buffer for unit


   if (filenm (1, int) == EOS)             # error, file not really open
      return
   if (lastc (int) > 0 & filacc (int) != READ)  # flush buffer
      call putch (NEWLINE, int)
#  if (mode (int) == DISK)
#     call rwind (int)                     # rewind file
   filenm (1, int) = EOS
   close (unit (int))

   return
   end
#-t-  close         1379  local  09/22/80  15:38:59
#-h-  rwind         1101  local  09/22/80  15:39:00
# rwind - rewind file (Fortran version)

   subroutine rwind (int)
   integer int

   # include io

 ## io - common block holding I/O information for portable primitives
 # put on a file called 'io'

 common /io/  unit (MAXOFILES), lastc (MAXOFILES), ccnt (MAXOFILES),
              filacc (MAXOFILES), mode (MAXOFILES), ftype (MAXOFILES),
              filenm (FILENAMESIZE, MAXOFILES),
              buffer (MAXLINE, MAXOFILES)

    integer unit        # fortran unit number
    integer lastc       # pointer to last character in unit's buffer
    integer ccnt        # number characters read/written in file
                        # (used only by seek)
    integer filacc      # access used to open file
                        # (READ, WRITE, READWRITE, or APPEND)
    integer mode        # device mode (DISK or TERMINAL)
    integer ftype       # file type (LOCAL, ASCII, BINARY)
    character filenm    # file name associated with unit
    character buffer    # line buffer for unit

   integer funit

   ccnt (int) = 0
   lastc (int) = 0
   funit = unit (int)
   rewind funit
   return
   end
#-t-  rwind         1101  local  09/22/80  15:39:00
#-h-  putch         1497  local  09/22/80  15:39:00
# putch - put character 'c' onto file 'int'
   # Portable version - fortran IO

   subroutine putch (c, int)
   character c
   filedes int

   integer  i, n

   # include io

 ## io - common block holding I/O information for portable primitives
 # put on a file called 'io'

 common /io/  unit (MAXOFILES), lastc (MAXOFILES), ccnt (MAXOFILES),
              filacc (MAXOFILES), mode (MAXOFILES), ftype (MAXOFILES),
              filenm (FILENAMESIZE, MAXOFILES),
              buffer (MAXLINE, MAXOFILES)

    integer unit        # fortran unit number
    integer lastc       # pointer to last character in unit's buffer
    integer ccnt        # number characters read/written in file
                        # (used only by seek)
    integer filacc      # access used to open file
                        # (READ, WRITE, READWRITE, or APPEND)
    integer mode        # device mode (DISK or TERMINAL)
    integer ftype       # file type (LOCAL, ASCII, BINARY)
    character filenm    # file name associated with unit
    character buffer    # line buffer for unit


   if (int <= 0)
      return
   n = lastc (int)
   if (n >= MAXLINE | c == NEWLINE) {     # time to write out record
      call putr (unit (int), buffer (1,int), n)
      lastc (int) = 0
      }
   if (c != NEWLINE) {
      lastc (int) = lastc (int) + 1
      n = lastc (int)
      buffer (n, int) = c
      }
   ccnt (int) = ccnt (int) + 1      #keep count of characters written

   return
   end
#-t-  putch         1497  local  09/22/80  15:39:00
#-h-  putr          279  local  09/22/80  15:39:01
# putr - write record of length 'n' to unit f

   subroutine putr (f, buf, n)
   integer f, n
   character buf (ARB)

   integer i

   if (n <= 0)
      write (f, 2)
   else
      write (f, 1) (buf (i), i = 1, n)

1       format (MAXCARD a1)
2       format ()

   return
   end
#-t-  putr          279  local  09/22/80  15:39:01
#-h-  getcmd        300  local  09/22/80  15:39:02
# getcmd - get string from DCL, stripping double quotes and handling escapes

   subroutine getcmd (arg)
   character arg(*)

   CHARACTER*ARGBUFSIZE arglin
   character c
   integer i, j, slen

   call lib$get_foreign (arglin,,slen)
   call str$trim (arglin, arglin, slen)
   j=1
   for (i = 1; i <= slen; i = i + 1) {
      c = ichar (arglin(i:i))
      if (c == BACKSLASH & i < slen) {
         i = i + 1
         arg(j) = ichar (arglin(i:i))
         j = j + 1
      }
      else if (c != DQUOTE) {
         arg(j) = c
         j = j + 1
      }
   }
   arg(j) = EOS
   return
   end
#-t-  getcmd        300  local  09/22/80  15:39:02
